containerRuntime: containerd
Kubernetes: true

operator:
  nodeSelector:
    role: "django" # this should go in its own nodegroup, but for the purpose of POC assigning group with enough memory

fluentbit:
  resources:
    limits:
      cpu: 500m
      memory: 200Mi
    requests:
      cpu: 10m
      memory: 25Mi
  serviceAccountAnnotations: {} # Specify additional custom annotations for fluentbit-serviceaccount
  logLevel: "error"

  nodeSelector:
    role: "django" # this should go in its own nodegroup, but for the purpose of POC assigning group with enough memory
  tolerations:
    - operator: Exists

  namespaceFluentBitCfgSelector: {}

  input:
    tail:
      enable: true
      refreshIntervalSeconds: 10
      memBufLimit: 5MB # limit of memory that Tail plugin can use when appending data to the Engine.
      bufferMaxSize: ""
      path: "/var/log/containers/*.log"
      skipLongLines: true
      readFromHead: false
      storageType: memory # # Use storageType as "filesystem" if you want to use filesystem as the buffering mechanism for tail input.
      pauseOnChunksOverlimit: "off"
    systemd:
      enable: false
      systemdFilter:
        enable: true
        filters: [] #??
      path: "/var/log/journal"
      includeKubelet: true
      stripUnderscores: "off"
      storageType: memory # Use storageType as "filesystem" if you want to use filesystem as the buffering mechanism for systemd input.
      pauseOnChunksOverlimit: "off"

  output:
    es:
      enable: true # true
      host: elasticsearch-es-http.eck-stack.svc # elasticsearch-logging-data.kubesphere-logging-system.svc
      port: 9200
      logstashPrefix: ks-logstash-log
      bufferSize: 20MB
      traceError: true # handling and debugging in the context of logs, not about forwarding trace data.
      logstashPrefixKey: ks-logstash-log
    #      suppressTypeName: "On"
    #      path: ""
    #      bufferSize: "4KB"
      index: "fluent-bit"
      httpUser:
        valueFrom:
          secretKeyRef:
            name: elasticsearch-es-elastic-user  # The secret name
            key: username  # The key within the secret holding the password
      httpPassword:
        valueFrom:
          secretKeyRef:
            name: elasticsearch-es-elastic-user  # The secret name
            key: password  # The key within the secret holding the password
#      httpUser: elastic
#      httpPassword:
      logstashFormat: true
      replaceDots: true
      enableTLS: false
    #      replaceDots: false
    #      enableTLS: false
    #      writeOperation: upsert
    #      tls:
    #        verify: On
    #        debug: 1
    #        caFile: "<Absolute path to CA certificate file>"
    #        caPath: "<Absolute path to scan for certificate files>"
    #        crtFile: "<Absolute path to private Key file>"
    #        keyFile: "<Absolute path to private Key file>"
    #        keyPassword:
    #        vhost: "<Hostname to be used for TLS SNI extension>"

    # Loki fluentbit ClusterOutput, to be encapsulated in fluentbit config
    # See https://github.com/fluent/fluent-operator/blob/master/docs/plugins/fluentbit/output/loki.md
    # See https://docs.fluentbit.io/manual/pipeline/outputs/loki

  # Configure the default filters in FluentBit.
  # The `filter` will filter and parse the collected log information and output the logs into a uniform format. You can choose whether to turn this on or not.
  filter:
    kubernetes:
      enable: true
      labels: false
      annotations: false
    containerd:
      # This is customized lua containerd log format converter, you can refer here:
      # https://github.com/fluent/fluent-operator/blob/master/charts/fluent-operator/templates/fluentbit-clusterfilter-containerd.yaml
      # https://github.com/fluent/fluent-operator/blob/master/charts/fluent-operator/templates/fluentbit-containerd-config.yaml
      enable: true
    systemd:
      enable: false

  # removes the hostPath mounts for varlibcontainers, varlogs and systemd.
  disableLogVolumes: false

nameOverride: ""
fullnameOverride: ""
namespaceOverride: ""